
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>structs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">lab3_go/internal/structs/array.go (95.8%)</option>
				
				<option value="file1">lab3_go/internal/structs/dlist.go (88.7%)</option>
				
				<option value="file2">lab3_go/internal/structs/hash.go (95.7%)</option>
				
				<option value="file3">lab3_go/internal/structs/queue.go (94.4%)</option>
				
				<option value="file4">lab3_go/internal/structs/slist.go (94.2%)</option>
				
				<option value="file5">lab3_go/internal/structs/stack.go (90.9%)</option>
				
				<option value="file6">lab3_go/internal/structs/tree.go (98.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

//структура динамического массива
type DynArray struct {
        Data []string `json:"data"` //данные массива (слайс) с тегом для json
}

// Конструктор
func NewDynArray() *DynArray <span class="cov8" title="1">{
        return &amp;DynArray{Data: make([]string, 0)} //инициализируем пустой слайс
}</span>

// Добавление элемента в конец
func (d *DynArray) Add(val string) <span class="cov8" title="1">{
        d.Data = append(d.Data, val) //встроенная функция расширения
}</span>

// Вставка элемента по индексу
func (d *DynArray) Insert(idx int, val string) <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt; len(d.Data) </span><span class="cov8" title="1">{ return }</span> //проверка границ
        //раздвигаем слайс: берем часть до idx, добавляем val, потом добавляем остаток
        <span class="cov8" title="1">d.Data = append(d.Data[:idx], append([]string{val}, d.Data[idx:]...)...)</span>
}

// Удаление элемента по индексу
func (d *DynArray) Remove(idx int) <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt;= len(d.Data) </span><span class="cov8" title="1">{ return }</span> //проверка границ
        //сшиваем часть до idx и часть после idx+1
        <span class="cov8" title="1">d.Data = append(d.Data[:idx], d.Data[idx+1:]...)</span>
}

// Получение элемента
func (d *DynArray) Get(idx int) string <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt;= len(d.Data) </span><span class="cov8" title="1">{ return "" }</span> //если индекс неверен
        <span class="cov8" title="1">return d.Data[idx]</span> //возвращаем значение
}

// Изменение элемента
func (d *DynArray) Set(idx int, val string) <span class="cov8" title="1">{
        if idx &gt;= 0 &amp;&amp; idx &lt; len(d.Data) </span><span class="cov8" title="1">{ d.Data[idx] = val }</span> //если индекс ок, меняем
}

// Печать массива
func (d *DynArray) Print() <span class="cov8" title="1">{
        fmt.Print("Array: ", d.Data, "\n") //вывод всего слайса
}</span>

// Сохранение в файл
func (d *DynArray) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename) //создаем файл
        if err != nil </span><span class="cov0" title="0">{ return err }</span> //если ошибка создания
        <span class="cov8" title="1">defer file.Close() //закроем при выходе
        return json.NewEncoder(file).Encode(d)</span> //пишем json
}

// Загрузка из файла
func (d *DynArray) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename) //открываем файл
        if err != nil </span><span class="cov8" title="1">{ return err }</span> //если ошибка
        <span class="cov8" title="1">defer file.Close() //закроем потом
        return json.NewDecoder(file).Decode(d)</span> //читаем json в структуру
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

type DList struct {
        Items []string `json:"items"` //храним как слайс для удобной JSON-сериализации
//Поля head и tail не экспортируем в JSON напрямую, восстановим их при Load
        head *DNode
        tail *DNode
}

// Узел двусвязного
type DNode struct {
        Val  string //значение
        Next *DNode //след
        Prev *DNode //пред
}

// Конструктор
func NewDList() *DList <span class="cov8" title="1">{
        return &amp;DList{Items: make([]string, 0)} //инициализация
}</span>

// Добавить в голову
func (l *DList) AddHead(val string) <span class="cov8" title="1">{
        // Обновляем слайс для JSON
        l.Items = append([]string{val}, l.Items...)

        n := &amp;DNode{Val: val} //новый узел
        if l.head == nil </span><span class="cov8" title="1">{ //если пуст
                l.head = n
                l.tail = n
        }</span> else<span class="cov0" title="0"> {
                n.Next = l.head //связь вперед
                l.head.Prev = n //связь назад
                l.head = n //новая голова
        }</span>
}

// Добавить в хвост
func (l *DList) AddTail(val string) <span class="cov8" title="1">{
        // Обновляем слайс для JSON
        l.Items = append(l.Items, val)

        n := &amp;DNode{Val: val} //новый узел
        if l.tail == nil </span><span class="cov8" title="1">{ //если пуст
                l.head = n
                l.tail = n
        }</span> else<span class="cov8" title="1"> {
                l.tail.Next = n //связь вперед
                n.Prev = l.tail //связь назад
                l.tail = n //новый хвост
        }</span>
}

// Удалить по значению
func (l *DList) DelVal(val string) <span class="cov8" title="1">{
        // 1. Удаляем из связного списка
        curr := l.head //итератор
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Val == val </span><span class="cov8" title="1">{ //нашли
                        if curr.Prev != nil </span><span class="cov8" title="1">{
                                curr.Prev.Next = curr.Next //обход слева
                        }</span> else<span class="cov8" title="1"> {
                                l.head = curr.Next //новая голова
                        }</span>

                        <span class="cov8" title="1">if curr.Next != nil </span><span class="cov8" title="1">{
                                curr.Next.Prev = curr.Prev //обход справа
                        }</span> else<span class="cov8" title="1"> {
                                l.tail = curr.Prev //новый хвост
                        }</span>
                        <span class="cov8" title="1">break</span> // Удаляем первое вхождение
                }
                <span class="cov8" title="1">curr = curr.Next</span> //дальше
        }

        // 2. Удаляем из слайса (для JSON)
        <span class="cov8" title="1">for i, v := range l.Items </span><span class="cov8" title="1">{
                if v == val </span><span class="cov8" title="1">{
                        l.Items = append(l.Items[:i], l.Items[i+1:]...) //вырезаем
                        break</span>
                }
        }
}

// Поиск значения
func (l *DList) Find(val string) bool <span class="cov8" title="1">{
        curr := l.head //итератор
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Val == val </span><span class="cov8" title="1">{
                        return true //нашли
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span>
        }
        <span class="cov8" title="1">return false</span> //не нашли
}

// Печать
func (l *DList) Print() <span class="cov8" title="1">{
        fmt.Print("DList: ")
        curr := l.head
        for curr != nil </span><span class="cov0" title="0">{
                fmt.Printf("%s &lt;-&gt; ", curr.Val)
                curr = curr.Next
        }</span>
        <span class="cov8" title="1">fmt.Println("nil")</span>
}

// Load загружает из JSON и восстанавливает связи
func (l *DList) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if err := json.NewDecoder(file).Decode(l); err != nil </span><span class="cov0" title="0">{ //читаем слайс
                return err
        }</span>

        // Пересобираем связный список из загруженного слайса Items
        <span class="cov8" title="1">l.head = nil
        l.tail = nil
        tempItems := l.Items
        l.Items = make([]string, 0) // сброс, AddTail заполнит заново и корректно
        for _, v := range tempItems </span><span class="cov8" title="1">{
                l.AddTail(v) //восстанавливаем структуру
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Сохранение
func (l *DList) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(l)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

// Узел хеш-таблицы (для цепочек)
type HashNode struct {
        Key   string    `json:"key"`//ключ
        Value string    `json:"value"`//значение
        Next  *HashNode `json:"next"`//след в цепочке
}

// Хеш-таблица
type HashTable struct {
        Buckets  []*HashNode `json:"buckets"`//массив списков
        Capacity int         `json:"capacity"`//емкость
}

// Конструктор
func NewHashTable(cap int) *HashTable <span class="cov8" title="1">{
        return &amp;HashTable{
                Buckets:  make([]*HashNode, cap), //выделяем память
                Capacity: cap,
        }
}</span>

// Хеш-функция
func (h *HashTable) hash(key string) int <span class="cov8" title="1">{
        sum := 0
        for _, c := range key </span><span class="cov8" title="1">{
                sum += int(c) //суммируем коды символов
        }</span>
        <span class="cov8" title="1">return sum % h.Capacity</span> //берем остаток от деления
}

// Вставка
func (h *HashTable) Put(key, val string) <span class="cov8" title="1">{
        idx := h.hash(key) //индекс корзины
        curr := h.Buckets[idx] //голова списка
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Key == key </span><span class="cov8" title="1">{ //если ключ уже есть
                        curr.Value = val //обновляем
                        return
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span> //дальше
        }
        //если нет, добавляем в начало цепочки
        <span class="cov8" title="1">h.Buckets[idx] = &amp;HashNode{Key: key, Value: val, Next: h.Buckets[idx]}</span>
}

// Получение значения
func (h *HashTable) Get(key string) string <span class="cov8" title="1">{
        idx := h.hash(key) //индекс
        curr := h.Buckets[idx] //голова
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Key == key </span><span class="cov8" title="1">{
                        return curr.Value //нашли
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span> //дальше
        }
        <span class="cov8" title="1">return ""</span> //не нашли
}

// Удаление
func (h *HashTable) Remove(key string) <span class="cov8" title="1">{
        idx := h.hash(key) //индекс
        curr := h.Buckets[idx] //голова
        var prev *HashNode //предыдущий

        for curr != nil </span><span class="cov8" title="1">{
                if curr.Key == key </span><span class="cov8" title="1">{ //нашли
                        if prev == nil </span><span class="cov0" title="0">{
                                h.Buckets[idx] = curr.Next //удаляем голову цепочки
                        }</span> else<span class="cov8" title="1"> {
                                prev.Next = curr.Next //связываем пред и след
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
                <span class="cov8" title="1">prev = curr //шаг
                curr = curr.Next</span> //шаг
        }
}

// Печать
func (h *HashTable) Print() <span class="cov8" title="1">{
        for i, b := range h.Buckets </span><span class="cov8" title="1">{
                fmt.Printf("[%d]: ", i)
                for b != nil </span><span class="cov8" title="1">{ //проход по цепочке
                        fmt.Printf("{%s:%s} -&gt; ", b.Key, b.Value)
                        b = b.Next
                }</span>
                <span class="cov8" title="1">fmt.Println("nil")</span>
        }
}

// Сохранение
func (h *HashTable) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(h)</span>
}

// Загрузка
func (h *HashTable) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewDecoder(file).Decode(h)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

// Структура очереди
type Queue struct {
        Data []string `json:"data"` //храним как массив для простоты
}

// Конструктор
func NewQueue() *Queue <span class="cov8" title="1">{ return &amp;Queue{Data: make([]string, 0)} }</span>

// Добавить элемент
func (q *Queue) Push(val string) <span class="cov8" title="1">{
        q.Data = append(q.Data, val) //в конец слайса
}</span>

// Извлечь элемент
func (q *Queue) Pop() string <span class="cov8" title="1">{
        if len(q.Data) == 0 </span><span class="cov8" title="1">{ return "" }</span> //пусто
        <span class="cov8" title="1">val := q.Data[0] //берем первый
        q.Data = q.Data[1:] //отрезаем голову слайса
        return val</span>
}

// Печать
func (q *Queue) Print() <span class="cov8" title="1">{
        fmt.Println("Queue:", q.Data)
}</span>

// Сохранение
func (q *Queue) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(q)</span>
}

// Загрузка
func (q *Queue) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewDecoder(file).Decode(q)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

// Структура узла
type SNode struct {
        Val  string `json:"val"`//значение
        Next *SNode `json:"next"` //указатель на следующий
}

// Структура списка
type SList struct {
        Head *SNode `json:"head"` //голова списка
}

// Конструктор
func NewSList() *SList <span class="cov8" title="1">{ return &amp;SList{} }</span> //возвращаем пустой список

// Добавить в начало
func (l *SList) AddHead(val string) <span class="cov8" title="1">{
        l.Head = &amp;SNode{Val: val, Next: l.Head} //новый узел указывает на старую голову
}</span>

// Добавить в конец
func (l *SList) AddTail(val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{ //если список пуст
                l.Head = &amp;SNode{Val: val} //новый узел - голова
                return
        }</span>
        <span class="cov8" title="1">curr := l.Head //итератор
        for curr.Next != nil </span><span class="cov8" title="1">{ curr = curr.Next }</span> //ищем последний
        <span class="cov8" title="1">curr.Next = &amp;SNode{Val: val}</span> //цепляем новый
}

// Удалить голову
func (l *SList) DelHead() <span class="cov8" title="1">{
        if l.Head != nil </span><span class="cov8" title="1">{ l.Head = l.Head.Next }</span> //сдвигаем голову вперед
}

// Удалить хвост
func (l *SList) DelTail() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{ return }</span> //пусто
        <span class="cov8" title="1">if l.Head.Next == nil </span><span class="cov8" title="1">{ l.Head = nil; return }</span> //один элемент
        <span class="cov8" title="1">curr := l.Head //итератор
        for curr.Next.Next != nil </span><span class="cov0" title="0">{ curr = curr.Next }</span> //ищем предпоследний
        <span class="cov8" title="1">curr.Next = nil</span> //обнуляем связь с последним
}

// Удалить по значению
func (l *SList) DelVal(val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{ return }</span> //пусто
        <span class="cov8" title="1">if l.Head.Val == val </span><span class="cov8" title="1">{ l.Head = l.Head.Next; return }</span> //если в голове
        <span class="cov8" title="1">curr := l.Head //итератор
        for curr.Next != nil &amp;&amp; curr.Next.Val != val </span><span class="cov0" title="0">{ curr = curr.Next }</span> //ищем
        <span class="cov8" title="1">if curr.Next != nil </span><span class="cov8" title="1">{ curr.Next = curr.Next.Next }</span> //перекидываем связь
}

// Поиск элемента
func (l *SList) Find(val string) bool <span class="cov8" title="1">{
        curr := l.Head //итератор
        for curr != nil </span><span class="cov8" title="1">{ //пока есть элементы
                if curr.Val == val </span><span class="cov8" title="1">{ return true }</span> //нашли
                <span class="cov8" title="1">curr = curr.Next</span> //дальше
        }
        <span class="cov8" title="1">return false</span> //не нашли
}

// Печать
func (l *SList) Print() <span class="cov8" title="1">{
        fmt.Print("SList: ")
        curr := l.Head
        for curr != nil </span><span class="cov8" title="1">{
                fmt.Printf("%s -&gt; ", curr.Val)
                curr = curr.Next
        }</span>
        <span class="cov8" title="1">fmt.Println("nil")</span>
}

// Сохранение
func (l *SList) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename) //файл
        if err != nil </span><span class="cov0" title="0">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(l)</span> //пишем
}

// Загрузка
func (l *SList) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename) //открываем
        if err != nil </span><span class="cov8" title="1">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewDecoder(file).Decode(l)</span> //читаем
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

// Структура стека
type Stack struct {
        Data []string `json:"data"` //храним данные
}

// Конструктор
func NewStack() *Stack <span class="cov8" title="1">{ return &amp;Stack{Data: make([]string, 0)} }</span>

// Добавить наверх
func (s *Stack) Push(val string) <span class="cov8" title="1">{
        s.Data = append(s.Data, val) //в конец слайса
}</span>

// Снять сверху
func (s *Stack) Pop() string <span class="cov8" title="1">{
        if len(s.Data) == 0 </span><span class="cov8" title="1">{ return "" }</span> //пусто
        <span class="cov8" title="1">lastIdx := len(s.Data) - 1 //индекс последнего
        val := s.Data[lastIdx] //берем значение
        s.Data = s.Data[:lastIdx] //уменьшаем слайс
        return val</span>
}

// Печать
func (s *Stack) Print() <span class="cov8" title="1">{
        fmt.Print("Stack (Top-&gt;Bottom): ")
        for i := len(s.Data)-1; i &gt;= 0; i-- </span><span class="cov0" title="0">{ //идем с конца
                fmt.Printf("[%s] ", s.Data[i])
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

// Сохранение
func (s *Stack) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(s)</span>
}

// Загрузка
func (s *Stack) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewDecoder(file).Decode(s)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

const (
        RED   = true
        BLACK = false
)

// RBNode - узел дерева
type RBNode struct {
        Key    int     `json:"key"`//ключ
        Color  bool    `json:"color"`// true=RED, false=BLACK
        Left   *RBNode `json:"left"`//левый сын
        Right  *RBNode `json:"right"`//правый сын
        Parent *RBNode `json:"-"`// Исключаем из JSON, чтобы не было циклов
}

// RBTree - обертка дерева
type RBTree struct {
        Root  *RBNode `json:"root"`//корень
        TNULL *RBNode `json:"-"`// Служебный узел (заглушка)
}

// NewRBTree - конструктор
func NewRBTree() *RBTree <span class="cov8" title="1">{
        tnull := &amp;RBNode{Color: BLACK} //заглушка всегда черная
        // Важно: TNULL должен быть отдельным объектом
        return &amp;RBTree{
                TNULL: tnull,
                Root:  tnull,
        }
}</span>

//Вспомогательные функции (Приватные)

// Левый поворот
func (t *RBTree) leftRotate(x *RBNode) <span class="cov8" title="1">{
        y := x.Right //правый сын
        x.Right = y.Left //перекидываем левого сына Y к X
        if y.Left != t.TNULL </span><span class="cov8" title="1">{
                y.Left.Parent = x //обновляем родителя
        }</span>
        <span class="cov8" title="1">y.Parent = x.Parent //связываем Y с родителем X
        if x.Parent == nil </span><span class="cov8" title="1">{
                t.Root = y //если корень
        }</span> else<span class="cov8" title="1"> if x == x.Parent.Left </span><span class="cov8" title="1">{
                x.Parent.Left = y //слева
        }</span> else<span class="cov8" title="1"> {
                x.Parent.Right = y //справа
        }</span>
        <span class="cov8" title="1">y.Left = x //X становится левым сыном Y
        x.Parent = y</span> //обновляем родителя X
}

// Правый поворот
func (t *RBTree) rightRotate(x *RBNode) <span class="cov8" title="1">{
        y := x.Left //левый сын
        x.Left = y.Right //перекидываем
        if y.Right != t.TNULL </span><span class="cov8" title="1">{
                y.Right.Parent = x //обновляем родителя
        }</span>
        <span class="cov8" title="1">y.Parent = x.Parent //связываем с дедом
        if x.Parent == nil </span><span class="cov8" title="1">{
                t.Root = y //корень
        }</span> else<span class="cov8" title="1"> if x == x.Parent.Right </span><span class="cov8" title="1">{
                x.Parent.Right = y //справа
        }</span> else<span class="cov8" title="1"> {
                x.Parent.Left = y //слева
        }</span>
        <span class="cov8" title="1">y.Right = x //X становится правым сыном Y
        x.Parent = y</span>
}

// Балансировка вставки
func (t *RBTree) insertFix(k *RBNode) <span class="cov8" title="1">{
        var u *RBNode //дядя
        for k.Parent.Color == RED </span><span class="cov8" title="1">{ //пока папа красный
                if k.Parent == k.Parent.Parent.Right </span><span class="cov8" title="1">{ //папа справа
                        u = k.Parent.Parent.Left //дядя слева
                        if u.Color == RED </span><span class="cov8" title="1">{ //случай 1: дядя красный
                                u.Color = BLACK
                                k.Parent.Color = BLACK
                                k.Parent.Parent.Color = RED
                                k = k.Parent.Parent //идем вверх
                        }</span> else<span class="cov8" title="1"> {
                                if k == k.Parent.Left </span><span class="cov8" title="1">{ //случай 2: зигзаг
                                        k = k.Parent
                                        t.rightRotate(k)
                                }</span>
                                //случай 3: линия
                                <span class="cov8" title="1">k.Parent.Color = BLACK
                                k.Parent.Parent.Color = RED
                                t.leftRotate(k.Parent.Parent)</span>
                        }
                } else<span class="cov8" title="1"> { //зеркальная ситуация
                        u = k.Parent.Parent.Right //дядя справа
                        if u.Color == RED </span><span class="cov8" title="1">{ //случай 1
                                u.Color = BLACK
                                k.Parent.Color = BLACK
                                k.Parent.Parent.Color = RED
                                k = k.Parent.Parent
                        }</span> else<span class="cov8" title="1"> {
                                if k == k.Parent.Right </span><span class="cov8" title="1">{ //случай 2
                                        k = k.Parent
                                        t.leftRotate(k)
                                }</span>
                                //случай 3
                                <span class="cov8" title="1">k.Parent.Color = BLACK
                                k.Parent.Parent.Color = RED
                                t.rightRotate(k.Parent.Parent)</span>
                        }
                }
                <span class="cov8" title="1">if k == t.Root </span><span class="cov8" title="1">{ break</span> } //дошли до корня
        }
        <span class="cov8" title="1">t.Root.Color = BLACK</span> //корень всегда черный
}

// Перенос поддерева
func (t *RBTree) transplant(u, v *RBNode) <span class="cov8" title="1">{
        if u.Parent == nil </span><span class="cov8" title="1">{
                t.Root = v //корень
        }</span> else<span class="cov8" title="1"> if u == u.Parent.Left </span><span class="cov8" title="1">{
                u.Parent.Left = v //слева
        }</span> else<span class="cov8" title="1"> {
                u.Parent.Right = v //справа
        }</span>
        <span class="cov8" title="1">v.Parent = u.Parent</span> //обновляем родителя
}

// Минимум в поддереве
func (t *RBTree) minimum(node *RBNode) *RBNode <span class="cov8" title="1">{
        for node.Left != t.TNULL </span><span class="cov8" title="1">{
                node = node.Left //идем влево до упора
        }</span>
        <span class="cov8" title="1">return node</span>
}

// Балансировка удаления
func (t *RBTree) deleteFix(x *RBNode) <span class="cov8" title="1">{
        var s *RBNode //брат
        for x != t.Root &amp;&amp; x.Color == BLACK </span><span class="cov8" title="1">{ //пока x черный и не корень
                if x == x.Parent.Left </span><span class="cov8" title="1">{ //мы слева
                        s = x.Parent.Right //брат справа
                        if s.Color == RED </span><span class="cov8" title="1">{ //случай 1
                                s.Color = BLACK
                                x.Parent.Color = RED
                                t.leftRotate(x.Parent)
                                s = x.Parent.Right
                        }</span>
                        <span class="cov8" title="1">if s.Left.Color == BLACK &amp;&amp; s.Right.Color == BLACK </span><span class="cov8" title="1">{ //случай 2
                                s.Color = RED
                                x = x.Parent
                        }</span> else<span class="cov8" title="1"> {
                                if s.Right.Color == BLACK </span><span class="cov8" title="1">{ //случай 3
                                        s.Left.Color = BLACK
                                        s.Color = RED
                                        t.rightRotate(s)
                                        s = x.Parent.Right
                                }</span>
                                <span class="cov8" title="1">s.Color = x.Parent.Color //случай 4
                                x.Parent.Color = BLACK
                                s.Right.Color = BLACK
                                t.leftRotate(x.Parent)
                                x = t.Root</span>
                        }
                } else<span class="cov8" title="1"> { //зеркально
                        s = x.Parent.Left
                        if s.Color == RED </span><span class="cov8" title="1">{
                                s.Color = BLACK
                                x.Parent.Color = RED
                                t.rightRotate(x.Parent)
                                s = x.Parent.Left
                        }</span>
                        <span class="cov8" title="1">if s.Right.Color == BLACK &amp;&amp; s.Left.Color == BLACK </span><span class="cov8" title="1">{
                                s.Color = RED
                                x = x.Parent
                        }</span> else<span class="cov8" title="1"> {
                                if s.Left.Color == BLACK </span><span class="cov8" title="1">{
                                        s.Right.Color = BLACK
                                        s.Color = RED
                                        t.leftRotate(s)
                                        s = x.Parent.Left
                                }</span>
                                <span class="cov8" title="1">s.Color = x.Parent.Color
                                x.Parent.Color = BLACK
                                s.Left.Color = BLACK
                                t.rightRotate(x.Parent)
                                x = t.Root</span>
                        }
                }
        }
        <span class="cov8" title="1">x.Color = BLACK</span> //x стал черным
}

// Вспомогательный поиск
func (t *RBTree) searchHelper(node *RBNode, key int) *RBNode <span class="cov8" title="1">{
        if node == t.TNULL || key == node.Key </span><span class="cov8" title="1">{
                return node //нашли или тупик
        }</span>
        <span class="cov8" title="1">if key &lt; node.Key </span><span class="cov8" title="1">{
                return t.searchHelper(node.Left, key) //влево
        }</span>
        <span class="cov8" title="1">return t.searchHelper(node.Right, key)</span> //вправо
}

//Публичные методы

// Insert - вставка ключа
func (t *RBTree) Insert(key int) <span class="cov8" title="1">{
        node := &amp;RBNode{Key: key, Color: RED, Left: t.TNULL, Right: t.TNULL, Parent: nil} //новый красный
        y := (*RBNode)(nil)
        x := t.Root

        for x != t.TNULL </span><span class="cov8" title="1">{ //спуск вниз
                y = x
                if node.Key &lt; x.Key </span><span class="cov8" title="1">{
                        x = x.Left
                }</span> else<span class="cov8" title="1"> {
                        x = x.Right
                }</span>
        }

        <span class="cov8" title="1">node.Parent = y //ставим родителя
        if y == nil </span><span class="cov8" title="1">{
                t.Root = node //корень
        }</span> else<span class="cov8" title="1"> if node.Key &lt; y.Key </span><span class="cov8" title="1">{
                y.Left = node //левый сын
        }</span> else<span class="cov8" title="1"> {
                y.Right = node //правый сын
        }</span>

        <span class="cov8" title="1">if node.Parent == nil </span><span class="cov8" title="1">{
                node.Color = BLACK //корень черный
                return
        }</span>
        <span class="cov8" title="1">if node.Parent.Parent == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">t.insertFix(node)</span> //балансировка
}

//удаление ключа
func (t *RBTree) Delete(key int) <span class="cov8" title="1">{
        z := t.searchHelper(t.Root, key) //ищем узел
        if z == t.TNULL </span><span class="cov8" title="1">{
                fmt.Println("Key not found")
                return
        }</span>

        <span class="cov8" title="1">var x, y *RBNode
        y = z
        yOrigColor := y.Color

        if z.Left == t.TNULL </span><span class="cov8" title="1">{
                x = z.Right
                t.transplant(z, z.Right) //замена правым
        }</span> else<span class="cov8" title="1"> if z.Right == t.TNULL </span><span class="cov8" title="1">{
                x = z.Left
                t.transplant(z, z.Left) //замена левым
        }</span> else<span class="cov8" title="1"> {
                y = t.minimum(z.Right) //ищем преемника
                yOrigColor = y.Color
                x = y.Right
                if y.Parent == z </span><span class="cov8" title="1">{
                        x.Parent = y
                }</span> else<span class="cov8" title="1"> {
                        t.transplant(y, y.Right)
                        y.Right = z.Right
                        y.Right.Parent = y
                }</span>
                <span class="cov8" title="1">t.transplant(z, y)
                y.Left = z.Left
                y.Left.Parent = y
                y.Color = z.Color</span>
        }
        <span class="cov8" title="1">if yOrigColor == BLACK </span><span class="cov8" title="1">{
                t.deleteFix(x) //балансировка если удалили черный
        }</span>
}

// Search - поиск ключа
func (t *RBTree) Search(k int) bool <span class="cov8" title="1">{
        return t.searchHelper(t.Root, k) != t.TNULL
}</span>

// Вспомогательная печать
func (t *RBTree) printHelper(root *RBNode, indent string, last bool) <span class="cov8" title="1">{
        if root != t.TNULL </span><span class="cov8" title="1">{
                fmt.Print(indent)
                if last </span><span class="cov8" title="1">{
                        fmt.Print("R----") //правый
                        indent += "   "
                }</span> else<span class="cov8" title="1"> {
                        fmt.Print("L----") //левый
                        indent += "|  "
                }</span>
                <span class="cov8" title="1">color := "BLK"
                if root.Color == RED </span><span class="cov8" title="1">{
                        color = "RED"
                }</span>
                <span class="cov8" title="1">fmt.Printf("%d(%s)\n", root.Key, color)
                t.printHelper(root.Left, indent, false) //рек лево
                t.printHelper(root.Right, indent, true)</span> //рек право
        }
}

// Print - красивый вывод дерева
func (t *RBTree) Print() <span class="cov8" title="1">{
        if t.Root == t.TNULL </span><span class="cov0" title="0">{
                fmt.Println("Tree is empty")
        }</span> else<span class="cov8" title="1"> {
                t.printHelper(t.Root, "", true)
        }</span>
}

//Сериализация

// Save - сохранение в JSON
func (t *RBTree) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename) //файл
        if err != nil </span><span class="cov0" title="0">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(t)</span> //пишем
}

// Load - загрузка из JSON
func (t *RBTree) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename) //открываем
        if err != nil </span><span class="cov8" title="1">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()

        // Сначала загружаем "сырую" структуру
        if err := json.NewDecoder(file).Decode(t); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
//После загрузки из JSON поле Parent потеряно (мы его не сохраняли, чтобы не было циклов),и TNULL не настроен.
        <span class="cov8" title="1">t.TNULL = &amp;RBNode{Color: BLACK}//Новый TNULL
        t.fixParentsAndTNULL(t.Root)//Рекурсивно чиним
        return nil</span>
}

//восстанавливает связи Parent и заменяет nil на TNULL
func (t *RBTree) fixParentsAndTNULL(node *RBNode) <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return
        }</span>
        // Если узел был сохранен как лист (nil в json), делаем его TNULL
        <span class="cov8" title="1">if node.Left == nil </span><span class="cov8" title="1">{
                node.Left = t.TNULL
        }</span> else<span class="cov8" title="1"> {
                node.Left.Parent = node
                t.fixParentsAndTNULL(node.Left)
        }</span>

        <span class="cov8" title="1">if node.Right == nil </span><span class="cov8" title="1">{
                node.Right = t.TNULL
        }</span> else<span class="cov8" title="1"> {
                node.Right.Parent = node
                t.fixParentsAndTNULL(node.Right)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

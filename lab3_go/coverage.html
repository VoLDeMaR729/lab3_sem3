
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>structs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">lab3_go/internal/structs/array.go (95.8%)</option>
				
				<option value="file1">lab3_go/internal/structs/dlist.go (88.7%)</option>
				
				<option value="file2">lab3_go/internal/structs/hash.go (95.7%)</option>
				
				<option value="file3">lab3_go/internal/structs/queue.go (94.4%)</option>
				
				<option value="file4">lab3_go/internal/structs/slist.go (94.2%)</option>
				
				<option value="file5">lab3_go/internal/structs/stack.go (90.9%)</option>
				
				<option value="file6">lab3_go/internal/structs/tree.go (98.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package structs

import (
 "encoding/json"
 "errors"
 "fmt"
 "os"
)

// Massive - –Ω–∞—à –∫–∞—Å—Ç–æ–º–Ω—ã–π –º–∞—Å—Å–∏–≤
type Massive struct {
 Data     []string json:"data"     // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ "—Å—ã—Ä–æ–π" –±–ª–æ–∫ –ø–∞–º—è—Ç–∏
 Size     int      json:"size"     // –†–µ–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
 Capacity int      json:"capacity" // –†–∞–∑–º–µ—Ä –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç–∏
}

/</span>/ NewMassive - –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
func NewMassive(initialCapacity int) *Massive {
 if initialCapacity &lt;= 0 {
  initialCapacity = 1
 }
 </span>return &amp;Massive{
  Data:     make([]string, initialCapacity), // –í—ã–¥–µ–ª—è–µ–º –ø–∞–º—è—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
  Size:     0,
  Capacity: initialCapacity,
 }
</span></span>}

</span>// expand - —Ä—É—á–Ω–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ (–∞–Ω–∞–ª–æ–≥ resize –≤ C++)
func (m *Massive) expand() {
 newCapacity := m.Capacity * 2
 newData := make([]string, newCapac<span class="cov8" title="1">ity) // 1. –í—ã–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é –ø–∞–º—è—Ç—å

</span></span> // 2. –í–†–£–ß–ù–£–Æ –∫–æ–ø–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ (–Ω–∏–∫–∞–∫–∏—Ö copy())
 <span class="cov8" title="1">for i := 0; i &lt; m.Size; i++ {
</span>  newData[i] = m.Data[i]
 }

 m.Data = newData // 3. –ü–µ—Ä–µ–∫–ª—é—<span class="cov8" title="1">á–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å
 m.Capacity = newCapacity
</span></span>}<span class="cov8" title="1">
</span>
// PushBack - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü
func (m *Massive) PushBack(val string) {
 if m.Size == m.Capacity {
  m.expand()
</span></span> }
 m.Data[m.Size] = val // –ü–∏—à–µ–º –≤ —Å–≤–æ–±–æ–¥–Ω—É—é —è—á–µ–π–∫—É
 m.Size++
}

/</span>/ Insert - –≤—Å—Ç–∞–≤–∫–∞ —Å–æ —Å–¥–≤–∏–≥–æ–º
func (m *Massive) Insert(index int, val string) error {
 if index &lt; 0 || index &gt; m.Size {
  return errors.New("index out of bounds")
 }

</span></span> <span class="cov8" title="1">if m.Size == m.Capacity {
  m.expand()
</span> }

 // –°–¥–≤–∏–≥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –í–ü–†–ê–í–û, —á—Ç–æ–±—ã –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –º–µ—Å—Ç–æ
 for i := m.Size; i &gt; index; i-- {
  m.Data[i] = m.Data[i-1]
 }
</span></span>
 m.Data[index] = val
</span> m.Size++
 return nil
}

// Remove - —É–¥–∞–ª–µ–Ω–∏–µ —Å–æ —Å–¥–≤–∏–≥–æ–º
func (m *Massive) Remove(index int) error {
 if index &lt; 0 || index &gt;= m.Size {
  return errors.New("index out of bounds")
 }

 // –°–¥–≤–∏–≥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –í–õ–ï–í–û, –∑–∞—Ç–∏—Ä–∞—è —É–¥–∞–ª—è–µ–º—ã–π
 for i := index; i &lt; m.Size-1; i++ {
  m.Data[i] = m.Data[i+1]
 }

 m.Data[m.Size-1] = "" // –ó–∞—á–∏—â–∞–µ–º —Ö–≤–æ—Å—Ç (–¥–ª—è —Å–±–æ—Ä—â–∏–∫–∞ –º—É—Å–æ—Ä–∞)
 m.Size--
 return nil
}

// Get
func (m *Massive) Get(index int) (string, error) {
 if index &lt; 0 || index &gt;= m.Size {
  return "", errors.New("index out of bounds")
 }
 return m.Data[index], nil
}

// Set
func (m *Massive) Set(index int, val string) error {
 if index &lt; 0 || index &gt;= m.Size {
  return errors.New("index out of bounds")
 }
 m.Data[index] = val
 return nil
}

// Print
func (m *Massive) Print() {
 fmt.Print("Massive: [ ")
 for i := 0; i &lt; m.Size; i++ {
  fmt.Print(m.Data[i], " ")
 }
 fmt.Println("]")
}

// Save (JSON)
func (m *Massive) Save(filename string) error {
 file, err := os.Create(filename)
 if err != nil {
  return err
 }
 defer file.Close()
 // –î–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞–º –Ω—É–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ–ª—å–∫–æ "–∂–∏–≤—ã–µ" –¥–∞–Ω–Ω—ã–µ, 
 // –Ω–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ Massive —Ö—Ä–∞–Ω–∏—Ç –∏ –º—É—Å–æ—Ä –≤ —Ö–≤–æ—Å—Ç–µ.
 // JSON —ç–Ω–∫–æ–¥–µ—Ä —Å–æ—Ö—Ä–∞–Ω–∏—Ç –≤—Å—ë –∫–∞–∫ –µ—Å—Ç—å
 encoder := json.NewEncoder(file)
 encoder.SetIndent("", "  ")
 return encoder.Encode(m)
}

// Load (JSON)
func (m *Massive) Load(filename string) error {
 file, err := os.Open(filename)
 if err != nil {
  return err
 }
 defer file.Close()

 decoder := json.NewDecoder(file)
 return decoder.Decode(m)
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

type DList struct {
        Items []string `json:"items"` //—Ö—Ä–∞–Ω–∏–º –∫–∞–∫ —Å–ª–∞–π—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π JSON-—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏
//–ü–æ–ª—è head –∏ tail –Ω–µ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤ JSON –Ω–∞–ø—Ä—è–º—É—é, –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–º –∏—Ö –ø—Ä–∏ Load
        head *DNode
        tail *DNode
}

// –£–∑–µ–ª –¥–≤—É—Å–≤—è–∑–Ω–æ–≥–æ
type DNode struct {
        Val  string //–∑–Ω–∞—á–µ–Ω–∏–µ
        Next *DNode //—Å–ª–µ–¥
        Prev *DNode //–ø—Ä–µ–¥
}

// –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
func NewDList() *DList <span class="cov8" title="1">{
        return &amp;DList{Items: make([]string, 0)} //–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
}</span>

// –î–æ–±–∞–≤–∏—Ç—å –≤ –≥–æ–ª–æ–≤—É
func (l *DList) AddHead(val string) <span class="cov8" title="1">{
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–∞–π—Å –¥–ª—è JSON
        l.Items = append([]string{val}, l.Items...)

        n := &amp;DNode{Val: val} //–Ω–æ–≤—ã–π —É–∑–µ–ª
        if l.head == nil </span><span class="cov8" title="1">{ //–µ—Å–ª–∏ –ø—É—Å—Ç
                l.head = n
                l.tail = n
        }</span> else<span class="cov0" title="0"> {
                n.Next = l.head //—Å–≤—è–∑—å –≤–ø–µ—Ä–µ–¥
                l.head.Prev = n //—Å–≤—è–∑—å –Ω–∞–∑–∞–¥
                l.head = n //–Ω–æ–≤–∞—è –≥–æ–ª–æ–≤–∞
        }</span>
}

// –î–æ–±–∞–≤–∏—Ç—å –≤ —Ö–≤–æ—Å—Ç
func (l *DList) AddTail(val string) <span class="cov8" title="1">{
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–∞–π—Å –¥–ª—è JSON
        l.Items = append(l.Items, val)

        n := &amp;DNode{Val: val} //–Ω–æ–≤—ã–π —É–∑–µ–ª
        if l.tail == nil </span><span class="cov8" title="1">{ //–µ—Å–ª–∏ –ø—É—Å—Ç
                l.head = n
                l.tail = n
        }</span> else<span class="cov8" title="1"> {
                l.tail.Next = n //—Å–≤—è–∑—å –≤–ø–µ—Ä–µ–¥
                n.Prev = l.tail //—Å–≤—è–∑—å –Ω–∞–∑–∞–¥
                l.tail = n //–Ω–æ–≤—ã–π —Ö–≤–æ—Å—Ç
        }</span>
}

// –£–¥–∞–ª–∏—Ç—å –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é
func (l *DList) DelVal(val string) <span class="cov8" title="1">{
        // 1. –£–¥–∞–ª—è–µ–º –∏–∑ —Å–≤—è–∑–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞
        curr := l.head //–∏—Ç–µ—Ä–∞—Ç–æ—Ä
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Val == val </span><span class="cov8" title="1">{ //–Ω–∞—à–ª–∏
                        if curr.Prev != nil </span><span class="cov8" title="1">{
                                curr.Prev.Next = curr.Next //–æ–±—Ö–æ–¥ —Å–ª–µ–≤–∞
                        }</span> else<span class="cov8" title="1"> {
                                l.head = curr.Next //–Ω–æ–≤–∞—è –≥–æ–ª–æ–≤–∞
                        }</span>

                        <span class="cov8" title="1">if curr.Next != nil </span><span class="cov8" title="1">{
                                curr.Next.Prev = curr.Prev //–æ–±—Ö–æ–¥ —Å–ø—Ä–∞–≤–∞
                        }</span> else<span class="cov8" title="1"> {
                                l.tail = curr.Prev //–Ω–æ–≤—ã–π —Ö–≤–æ—Å—Ç
                        }</span>
                        <span class="cov8" title="1">break</span> // –£–¥–∞–ª—è–µ–º –ø–µ—Ä–≤–æ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ
                }
                <span class="cov8" title="1">curr = curr.Next</span> //–¥–∞–ª—å—à–µ
        }

        // 2. –£–¥–∞–ª—è–µ–º –∏–∑ —Å–ª–∞–π—Å–∞ (–¥–ª—è JSON)
        <span class="cov8" title="1">for i, v := range l.Items </span><span class="cov8" title="1">{
                if v == val </span><span class="cov8" title="1">{
                        l.Items = append(l.Items[:i], l.Items[i+1:]...) //–≤—ã—Ä–µ–∑–∞–µ–º
                        break</span>
                }
        }
}

// –ü–æ–∏—Å–∫ –∑–Ω–∞—á–µ–Ω–∏—è
func (l *DList) Find(val string) bool <span class="cov8" title="1">{
        curr := l.head //–∏—Ç–µ—Ä–∞—Ç–æ—Ä
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Val == val </span><span class="cov8" title="1">{
                        return true //–Ω–∞—à–ª–∏
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span>
        }
        <span class="cov8" title="1">return false</span> //–Ω–µ –Ω–∞—à–ª–∏
}

// –ü–µ—á–∞—Ç—å
func (l *DList) Print() <span class="cov8" title="1">{
        fmt.Print("DList: ")
        curr := l.head
        for curr != nil </span><span class="cov0" title="0">{
                fmt.Printf("%s &lt;-&gt; ", curr.Val)
                curr = curr.Next
        }</span>
        <span class="cov8" title="1">fmt.Println("nil")</span>
}

// Load –∑–∞–≥—Ä—É–∂–∞–µ—Ç –∏–∑ JSON –∏ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–≤—è–∑–∏
func (l *DList) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if err := json.NewDecoder(file).Decode(l); err != nil </span><span class="cov0" title="0">{ //—á–∏—Ç–∞–µ–º —Å–ª–∞–π—Å
                return err
        }</span>

        // –ü–µ—Ä–µ—Å–æ–±–∏—Ä–∞–µ–º —Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∏–∑ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Å–ª–∞–π—Å–∞ Items
        <span class="cov8" title="1">l.head = nil
        l.tail = nil
        tempItems := l.Items
        l.Items = make([]string, 0) // —Å–±—Ä–æ—Å, AddTail –∑–∞–ø–æ–ª–Ω–∏—Ç –∑–∞–Ω–æ–≤–æ –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
        for _, v := range tempItems </span><span class="cov8" title="1">{
                l.AddTail(v) //–≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
func (l *DList) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(l)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

// –£–∑–µ–ª —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã (–¥–ª—è —Ü–µ–ø–æ—á–µ–∫)
type HashNode struct {
        Key   string    `json:"key"`//–∫–ª—é—á
        Value string    `json:"value"`//–∑–Ω–∞—á–µ–Ω–∏–µ
        Next  *HashNode `json:"next"`//—Å–ª–µ–¥ –≤ —Ü–µ–ø–æ—á–∫–µ
}

// –•–µ—à-—Ç–∞–±–ª–∏—Ü–∞
type HashTable struct {
        Buckets  []*HashNode `json:"buckets"`//–º–∞—Å—Å–∏–≤ —Å–ø–∏—Å–∫–æ–≤
        Capacity int         `json:"capacity"`//–µ–º–∫–æ—Å—Ç—å
}

// –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
func NewHashTable(cap int) *HashTable <span class="cov8" title="1">{
        return &amp;HashTable{
                Buckets:  make([]*HashNode, cap), //–≤—ã–¥–µ–ª—è–µ–º –ø–∞–º—è—Ç—å
                Capacity: cap,
        }
}</span>

// –•–µ—à-—Ñ—É–Ω–∫—Ü–∏—è
func (h *HashTable) hash(key string) int <span class="cov8" title="1">{
        sum := 0
        for _, c := range key </span><span class="cov8" title="1">{
                sum += int(c) //—Å—É–º–º–∏—Ä—É–µ–º –∫–æ–¥—ã —Å–∏–º–≤–æ–ª–æ–≤
        }</span>
        <span class="cov8" title="1">return sum % h.Capacity</span> //–±–µ—Ä–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –æ—Ç –¥–µ–ª–µ–Ω–∏—è
}

// –í—Å—Ç–∞–≤–∫–∞
func (h *HashTable) Put(key, val string) <span class="cov8" title="1">{
        idx := h.hash(key) //–∏–Ω–¥–µ–∫—Å –∫–æ—Ä–∑–∏–Ω—ã
        curr := h.Buckets[idx] //–≥–æ–ª–æ–≤–∞ —Å–ø–∏—Å–∫–∞
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Key == key </span><span class="cov8" title="1">{ //–µ—Å–ª–∏ –∫–ª—é—á —É–∂–µ –µ—Å—Ç—å
                        curr.Value = val //–æ–±–Ω–æ–≤–ª—è–µ–º
                        return
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span> //–¥–∞–ª—å—à–µ
        }
        //–µ—Å–ª–∏ –Ω–µ—Ç, –¥–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ —Ü–µ–ø–æ—á–∫–∏
        <span class="cov8" title="1">h.Buckets[idx] = &amp;HashNode{Key: key, Value: val, Next: h.Buckets[idx]}</span>
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
func (h *HashTable) Get(key string) string <span class="cov8" title="1">{
        idx := h.hash(key) //–∏–Ω–¥–µ–∫—Å
        curr := h.Buckets[idx] //–≥–æ–ª–æ–≤–∞
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Key == key </span><span class="cov8" title="1">{
                        return curr.Value //–Ω–∞—à–ª–∏
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span> //–¥–∞–ª—å—à–µ
        }
        <span class="cov8" title="1">return ""</span> //–Ω–µ –Ω–∞—à–ª–∏
}

// –£–¥–∞–ª–µ–Ω–∏–µ
func (h *HashTable) Remove(key string) <span class="cov8" title="1">{
        idx := h.hash(key) //–∏–Ω–¥–µ–∫—Å
        curr := h.Buckets[idx] //–≥–æ–ª–æ–≤–∞
        var prev *HashNode //–ø—Ä–µ–¥—ã–¥—É—â–∏–π

        for curr != nil </span><span class="cov8" title="1">{
                if curr.Key == key </span><span class="cov8" title="1">{ //–Ω–∞—à–ª–∏
                        if prev == nil </span><span class="cov0" title="0">{
                                h.Buckets[idx] = curr.Next //—É–¥–∞–ª—è–µ–º –≥–æ–ª–æ–≤—É —Ü–µ–ø–æ—á–∫–∏
                        }</span> else<span class="cov8" title="1"> {
                                prev.Next = curr.Next //—Å–≤—è–∑—ã–≤–∞–µ–º –ø—Ä–µ–¥ –∏ —Å–ª–µ–¥
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
                <span class="cov8" title="1">prev = curr //—à–∞–≥
                curr = curr.Next</span> //—à–∞–≥
        }
}

// –ü–µ—á–∞—Ç—å
func (h *HashTable) Print() <span class="cov8" title="1">{
        for i, b := range h.Buckets </span><span class="cov8" title="1">{
                fmt.Printf("[%d]: ", i)
                for b != nil </span><span class="cov8" title="1">{ //–ø—Ä–æ—Ö–æ–¥ –ø–æ —Ü–µ–ø–æ—á–∫–µ
                        fmt.Printf("{%s:%s} -&gt; ", b.Key, b.Value)
                        b = b.Next
                }</span>
                <span class="cov8" title="1">fmt.Println("nil")</span>
        }
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
func (h *HashTable) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(h)</span>
}

// –ó–∞–≥—Ä—É–∑–∫–∞
func (h *HashTable) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewDecoder(file).Decode(h)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—á–µ—Ä–µ–¥–∏
type Queue struct {
        Data []string `json:"data"` //—Ö—Ä–∞–Ω–∏–º –∫–∞–∫ –º–∞—Å—Å–∏–≤ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã
}

// –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
func NewQueue() *Queue <span class="cov8" title="1">{ return &amp;Queue{Data: make([]string, 0)} }</span>

// –î–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç
func (q *Queue) Push(val string) <span class="cov8" title="1">{
        q.Data = append(q.Data, val) //–≤ –∫–æ–Ω–µ—Ü —Å–ª–∞–π—Å–∞
}</span>

// –ò–∑–≤–ª–µ—á—å —ç–ª–µ–º–µ–Ω—Ç
func (q *Queue) Pop() string <span class="cov8" title="1">{
        if len(q.Data) == 0 </span><span class="cov8" title="1">{ return "" }</span> //–ø—É—Å—Ç–æ
        <span class="cov8" title="1">val := q.Data[0] //–±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π
        q.Data = q.Data[1:] //–æ—Ç—Ä–µ–∑–∞–µ–º –≥–æ–ª–æ–≤—É —Å–ª–∞–π—Å–∞
        return val</span>
}

// –ü–µ—á–∞—Ç—å
func (q *Queue) Print() <span class="cov8" title="1">{
        fmt.Println("Queue:", q.Data)
}</span>

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
func (q *Queue) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(q)</span>
}

// –ó–∞–≥—Ä—É–∑–∫–∞
func (q *Queue) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewDecoder(file).Decode(q)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package structs

import (
 "encoding/json"
 "fmt"
 "os"
)

// SNode - —É–∑–µ–ª
type SNode struct {
 Val  string json:"val"
 Next *SNode json:"next"
}

// SinglyLinkedList - —Å–ø–∏—Å–æ–∫
type SinglyLinkedList struct {
 Head *SNode json:"head"
}

// PushHead - –¥–æ–±–∞–≤–∏—Ç—å –≤ –Ω–∞—á–∞–ª–æ
func (l *SinglyLinkedLi<span class="cov8" title="1">st) PushHead(val st</span>ring) {
 newNode := &amp;SNode{Val: val, Next: l.Head}
 l.Head = newNode
}

/</span>/ PushTail - –¥–æ–±–∞–≤–∏—Ç—å –≤ –∫–æ–Ω–µ—Ü
func (l *SinglyLinkedList) PushTail(val string) {
 newNode := &amp;SNode{Val: val, Next: nil}
 if l.Head == nil {
  l.Head = newNode</span><span class="cov8" title="1">
  return
 }
 c</span>urr := l.Head
 <span class="cov8" title="1">for curr.Next != nil {
  curr = curr.Next
</span></span> <span class="cov8" title="1">}
</span> curr.Next = newNode
}

// InsertAfter - –≤—Å—Ç–∞–<span class="cov8" title="1">≤–∫–∞ –ø–æ—Å–ª–µ
func (l *SinglyLin</span><span class="cov8" title="1">kedList) InsertAfter(tar</span>get string, val string) {
 curr := l.Head
 for curr != nil &amp;&amp; curr.Val != target {
  curr = curr.Next
 }
 if curr != nil {
</span></span> <span class="cov8" title="1"> newNode := &amp;SNode{Val</span><span class="cov8" title="1">: val, Next: curr.Next}
</span> <span class="cov8" title="1"> curr.Next = newNode
 }
</span></span>}<span class="cov8" title="1">
</span>
// InsertBefore - –≤—Å—Ç–∞–≤–∫–∞ –ø–µ—Ä–µ–¥
func (l *SinglyLinkedList) InsertBefore(target string, val string) {
 if l.Head == nil { return }
 
</span></span> <span class="cov8" title="1">if l.Head.Val == targ</span><span class="cov8" title="1">et {
</span> <span class="cov8" title="1"> l.PushHead(val)
  return
</span></span> <span class="cov8" title="1">}
</span></span> 
 curr := l.Head
 for curr.Next != nil &amp;&amp; curr.Next.Val != target {
  curr = curr.Next
 }
 
</span> if curr.Next != nil </span><span class="cov8" title="1">{
</span>  <span class="cov8" title="1">newNode := &amp;SNod</span>e{Val: val, Next: curr.Next}
  curr.Next = newNode
 <span class="cov8" title="1">}
</span>}

// DeleteHead
func (l *SinglyLinkedLis<span class="cov8" title="1">t) DeleteHead() {
 if l.Head != nil {
  l.Head = l.Head.Next
 }
</span>}

//</span> DeleteTail
f<span class="cov8" title="1">unc (l *SinglyLink</span>edList) DeleteTail() {
 if l.Head == nil { return }
 if l.Head.Next == nil {
  l.Head = nil
  return
 }
 curr := l.Head</span><span class="cov0" title="0">
</span> <span class="cov8" title="1">for curr.Next.Next != nil {
  curr = curr.Next
</span> }
 curr.Next = nil
}

// DeleteByValue
func (l *Singly</span><span class="cov8" title="1">LinkedList) De</span>leteByValue(val string) {
 <span class="cov8" title="1">if l.Head == nil { return }
 if l.Head.Val == val {
</span>  l.DeleteHead()
  return
 }
 curr := l.Head
 for curr.Next != nil &amp;&amp; curr.Next.Val != val {
  curr = curr.Next
 }
 if curr.Next != nil {
  curr.Next = curr.Next.Next
 }
}

// DeleteAfter
func (l *SinglyLinkedList) DeleteAfter(target string) {
 curr := l.Head
 for curr != nil &amp;&amp; curr.Val != target {
  curr = curr.Next
 }
 if curr != nil &amp;&amp; curr.Next != nil {
  curr.Next = curr.Next.Next
 }
}

// DeleteBefore
func (l *SinglyLinkedList) DeleteBefore(target string) {
 if l.Head == nil || l.Head.Next == nil { return }
 
 if l.Head.Next.Val == target {
  l.DeleteHead()
  return
 }
 
 curr := l.Head
 for curr.Next.Next != nil &amp;&amp; curr.Next.Next.Val != target {
  curr = curr.Next
 }
 
 if curr.Next.Next != nil {
  curr.Next = curr.Next.Next
 }
}

// Find
func (l *SinglyLinkedList) Find(val string) bool {
 curr := l.Head
 for curr != nil {
  if curr.Val == val { return true }
  curr = curr.Next
 }
 return false
}

// Print
func (l *SinglyLinkedList) Print() {
 fmt.Print("SList: ")
 curr := l.Head
 for curr != nil {
  fmt.Print(curr.Val, " -&gt; ")
  curr = curr.Next
 }
 fmt.Println("NULL")
}

// –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è (JSON)
func (l *SinglyLinkedList) Save(filename string) error {
 file, err := os.Create(filename)
 if err != nil { return err }
 defer file.Close()
 
 // –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–ª–∞–π—Å –¥–ª—è —á–∏—Å—Ç–æ–≥–æ JSON
 var data []string
 curr := l.Head
 for curr != nil {
  data = append(data, curr.Val)
  curr = curr.Next
 }
 
 encoder := json.NewEncoder(file)
 encoder.SetIndent("", "  ")
 return encoder.Encode(data)
}

// –î–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è (JSON)
func (l *SinglyLinkedList) Load(filename string) error {
 file, err := os.Open(filename)
 if err != nil { return err }
 defer file.Close()
 
 var data []string
 decoder := json.NewDecoder(file)
 if err := decoder.Decode(&amp;data); err != nil { return err }
 
 l.Head = nil
 for _, v := range data {
  l.PushTail(v)
 }
 return nil
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å—Ç–µ–∫–∞
type Stack struct {
        Data []string `json:"data"` //—Ö—Ä–∞–Ω–∏–º –¥–∞–Ω–Ω—ã–µ
}

// –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
func NewStack() *Stack <span class="cov8" title="1">{ return &amp;Stack{Data: make([]string, 0)} }</span>

// –î–æ–±–∞–≤–∏—Ç—å –Ω–∞–≤–µ—Ä—Ö
func (s *Stack) Push(val string) <span class="cov8" title="1">{
        s.Data = append(s.Data, val) //–≤ –∫–æ–Ω–µ—Ü —Å–ª–∞–π—Å–∞
}</span>

// –°–Ω—è—Ç—å —Å–≤–µ—Ä—Ö—É
func (s *Stack) Pop() string <span class="cov8" title="1">{
        if len(s.Data) == 0 </span><span class="cov8" title="1">{ return "" }</span> //–ø—É—Å—Ç–æ
        <span class="cov8" title="1">lastIdx := len(s.Data) - 1 //–∏–Ω–¥–µ–∫—Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ
        val := s.Data[lastIdx] //–±–µ—Ä–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
        s.Data = s.Data[:lastIdx] //—É–º–µ–Ω—å—à–∞–µ–º —Å–ª–∞–π—Å
        return val</span>
}

// –ü–µ—á–∞—Ç—å
func (s *Stack) Print() <span class="cov8" title="1">{
        fmt.Print("Stack (Top-&gt;Bottom): ")
        for i := len(s.Data)-1; i &gt;= 0; i-- </span><span class="cov0" title="0">{ //–∏–¥–µ–º —Å –∫–æ–Ω—Ü–∞
                fmt.Printf("[%s] ", s.Data[i])
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
func (s *Stack) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(s)</span>
}

// –ó–∞–≥—Ä—É–∑–∫–∞
func (s *Stack) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewDecoder(file).Decode(s)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package structs

import (
        "encoding/json"
        "fmt"
        "os"
)

const (
        RED   = true
        BLACK = false
)

// RBNode - —É–∑–µ–ª –¥–µ—Ä–µ–≤–∞
type RBNode struct {
        Key    int     `json:"key"`//–∫–ª—é—á
        Color  bool    `json:"color"`// true=RED, false=BLACK
        Left   *RBNode `json:"left"`//–ª–µ–≤—ã–π —Å—ã–Ω
        Right  *RBNode `json:"right"`//–ø—Ä–∞–≤—ã–π —Å—ã–Ω
        Parent *RBNode `json:"-"`// –ò—Å–∫–ª—é—á–∞–µ–º –∏–∑ JSON, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Ü–∏–∫–ª–æ–≤
}

// RBTree - –æ–±–µ—Ä—Ç–∫–∞ –¥–µ—Ä–µ–≤–∞
type RBTree struct {
        Root  *RBNode `json:"root"`//–∫–æ—Ä–µ–Ω—å
        TNULL *RBNode `json:"-"`// –°–ª—É–∂–µ–±–Ω—ã–π —É–∑–µ–ª (–∑–∞–≥–ª—É—à–∫–∞)
}

// NewRBTree - –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
func NewRBTree() *RBTree <span class="cov8" title="1">{
        tnull := &amp;RBNode{Color: BLACK} //–∑–∞–≥–ª—É—à–∫–∞ –≤—Å–µ–≥–¥–∞ —á–µ—Ä–Ω–∞—è
        // –í–∞–∂–Ω–æ: TNULL –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–º –æ–±—ä–µ–∫—Ç–æ–º
        return &amp;RBTree{
                TNULL: tnull,
                Root:  tnull,
        }
}</span>

//–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (–ü—Ä–∏–≤–∞—Ç–Ω—ã–µ)

// –õ–µ–≤—ã–π –ø–æ–≤–æ—Ä–æ—Ç
func (t *RBTree) leftRotate(x *RBNode) <span class="cov8" title="1">{
        y := x.Right //–ø—Ä–∞–≤—ã–π —Å—ã–Ω
        x.Right = y.Left //–ø–µ—Ä–µ–∫–∏–¥—ã–≤–∞–µ–º –ª–µ–≤–æ–≥–æ —Å—ã–Ω–∞ Y –∫ X
        if y.Left != t.TNULL </span><span class="cov8" title="1">{
                y.Left.Parent = x //–æ–±–Ω–æ–≤–ª—è–µ–º —Ä–æ–¥–∏—Ç–µ–ª—è
        }</span>
        <span class="cov8" title="1">y.Parent = x.Parent //—Å–≤—è–∑—ã–≤–∞–µ–º Y —Å —Ä–æ–¥–∏—Ç–µ–ª–µ–º X
        if x.Parent == nil </span><span class="cov8" title="1">{
                t.Root = y //–µ—Å–ª–∏ –∫–æ—Ä–µ–Ω—å
        }</span> else<span class="cov8" title="1"> if x == x.Parent.Left </span><span class="cov8" title="1">{
                x.Parent.Left = y //—Å–ª–µ–≤–∞
        }</span> else<span class="cov8" title="1"> {
                x.Parent.Right = y //—Å–ø—Ä–∞–≤–∞
        }</span>
        <span class="cov8" title="1">y.Left = x //X —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ª–µ–≤—ã–º —Å—ã–Ω–æ–º Y
        x.Parent = y</span> //–æ–±–Ω–æ–≤–ª—è–µ–º —Ä–æ–¥–∏—Ç–µ–ª—è X
}

// –ü—Ä–∞–≤—ã–π –ø–æ–≤–æ—Ä–æ—Ç
func (t *RBTree) rightRotate(x *RBNode) <span class="cov8" title="1">{
        y := x.Left //–ª–µ–≤—ã–π —Å—ã–Ω
        x.Left = y.Right //–ø–µ—Ä–µ–∫–∏–¥—ã–≤–∞–µ–º
        if y.Right != t.TNULL </span><span class="cov8" title="1">{
                y.Right.Parent = x //–æ–±–Ω–æ–≤–ª—è–µ–º —Ä–æ–¥–∏—Ç–µ–ª—è
        }</span>
        <span class="cov8" title="1">y.Parent = x.Parent //—Å–≤—è–∑—ã–≤–∞–µ–º —Å –¥–µ–¥–æ–º
        if x.Parent == nil </span><span class="cov8" title="1">{
                t.Root = y //–∫–æ—Ä–µ–Ω—å
        }</span> else<span class="cov8" title="1"> if x == x.Parent.Right </span><span class="cov8" title="1">{
                x.Parent.Right = y //—Å–ø—Ä–∞–≤–∞
        }</span> else<span class="cov8" title="1"> {
                x.Parent.Left = y //—Å–ª–µ–≤–∞
        }</span>
        <span class="cov8" title="1">y.Right = x //X —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø—Ä–∞–≤—ã–º —Å—ã–Ω–æ–º Y
        x.Parent = y</span>
}

// –ë–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ –≤—Å—Ç–∞–≤–∫–∏
func (t *RBTree) insertFix(k *RBNode) <span class="cov8" title="1">{
        var u *RBNode //–¥—è–¥—è
        for k.Parent.Color == RED </span><span class="cov8" title="1">{ //–ø–æ–∫–∞ –ø–∞–ø–∞ –∫—Ä–∞—Å–Ω—ã–π
                if k.Parent == k.Parent.Parent.Right </span><span class="cov8" title="1">{ //–ø–∞–ø–∞ —Å–ø—Ä–∞–≤–∞
                        u = k.Parent.Parent.Left //–¥—è–¥—è —Å–ª–µ–≤–∞
                        if u.Color == RED </span><span class="cov8" title="1">{ //—Å–ª—É—á–∞–π 1: –¥—è–¥—è –∫—Ä–∞—Å–Ω—ã–π
                                u.Color = BLACK
                                k.Parent.Color = BLACK
                                k.Parent.Parent.Color = RED
                                k = k.Parent.Parent //–∏–¥–µ–º –≤–≤–µ—Ä—Ö
                        }</span> else<span class="cov8" title="1"> {
                                if k == k.Parent.Left </span><span class="cov8" title="1">{ //—Å–ª—É—á–∞–π 2: –∑–∏–≥–∑–∞–≥
                                        k = k.Parent
                                        t.rightRotate(k)
                                }</span>
                                //—Å–ª—É—á–∞–π 3: –ª–∏–Ω–∏—è
                                <span class="cov8" title="1">k.Parent.Color = BLACK
                                k.Parent.Parent.Color = RED
                                t.leftRotate(k.Parent.Parent)</span>
                        }
                } else<span class="cov8" title="1"> { //–∑–µ—Ä–∫–∞–ª—å–Ω–∞—è —Å–∏—Ç—É–∞—Ü–∏—è
                        u = k.Parent.Parent.Right //–¥—è–¥—è —Å–ø—Ä–∞–≤–∞
                        if u.Color == RED </span><span class="cov8" title="1">{ //—Å–ª—É—á–∞–π 1
                                u.Color = BLACK
                                k.Parent.Color = BLACK
                                k.Parent.Parent.Color = RED
                                k = k.Parent.Parent
                        }</span> else<span class="cov8" title="1"> {
                                if k == k.Parent.Right </span><span class="cov8" title="1">{ //—Å–ª—É—á–∞–π 2
                                        k = k.Parent
                                        t.leftRotate(k)
                                }</span>
                                //—Å–ª—É—á–∞–π 3
                                <span class="cov8" title="1">k.Parent.Color = BLACK
                                k.Parent.Parent.Color = RED
                                t.rightRotate(k.Parent.Parent)</span>
                        }
                }
                <span class="cov8" title="1">if k == t.Root </span><span class="cov8" title="1">{ break</span> } //–¥–æ—à–ª–∏ –¥–æ –∫–æ—Ä–Ω—è
        }
        <span class="cov8" title="1">t.Root.Color = BLACK</span> //–∫–æ—Ä–µ–Ω—å –≤—Å–µ–≥–¥–∞ —á–µ—Ä–Ω—ã–π
}

// –ü–µ—Ä–µ–Ω–æ—Å –ø–æ–¥–¥–µ—Ä–µ–≤–∞
func (t *RBTree) transplant(u, v *RBNode) <span class="cov8" title="1">{
        if u.Parent == nil </span><span class="cov8" title="1">{
                t.Root = v //–∫–æ—Ä–µ–Ω—å
        }</span> else<span class="cov8" title="1"> if u == u.Parent.Left </span><span class="cov8" title="1">{
                u.Parent.Left = v //—Å–ª–µ–≤–∞
        }</span> else<span class="cov8" title="1"> {
                u.Parent.Right = v //—Å–ø—Ä–∞–≤–∞
        }</span>
        <span class="cov8" title="1">v.Parent = u.Parent</span> //–æ–±–Ω–æ–≤–ª—è–µ–º —Ä–æ–¥–∏—Ç–µ–ª—è
}

// –ú–∏–Ω–∏–º—É–º –≤ –ø–æ–¥–¥–µ—Ä–µ–≤–µ
func (t *RBTree) minimum(node *RBNode) *RBNode <span class="cov8" title="1">{
        for node.Left != t.TNULL </span><span class="cov8" title="1">{
                node = node.Left //–∏–¥–µ–º –≤–ª–µ–≤–æ –¥–æ —É–ø–æ—Ä–∞
        }</span>
        <span class="cov8" title="1">return node</span>
}

// –ë–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è
func (t *RBTree) deleteFix(x *RBNode) <span class="cov8" title="1">{
        var s *RBNode //–±—Ä–∞—Ç
        for x != t.Root &amp;&amp; x.Color == BLACK </span><span class="cov8" title="1">{ //–ø–æ–∫–∞ x —á–µ—Ä–Ω—ã–π –∏ –Ω–µ –∫–æ—Ä–µ–Ω—å
                if x == x.Parent.Left </span><span class="cov8" title="1">{ //–º—ã —Å–ª–µ–≤–∞
                        s = x.Parent.Right //–±—Ä–∞—Ç —Å–ø—Ä–∞–≤–∞
                        if s.Color == RED </span><span class="cov8" title="1">{ //—Å–ª—É—á–∞–π 1
                                s.Color = BLACK
                                x.Parent.Color = RED
                                t.leftRotate(x.Parent)
                                s = x.Parent.Right
                        }</span>
                        <span class="cov8" title="1">if s.Left.Color == BLACK &amp;&amp; s.Right.Color == BLACK </span><span class="cov8" title="1">{ //—Å–ª—É—á–∞–π 2
                                s.Color = RED
                                x = x.Parent
                        }</span> else<span class="cov8" title="1"> {
                                if s.Right.Color == BLACK </span><span class="cov8" title="1">{ //—Å–ª—É—á–∞–π 3
                                        s.Left.Color = BLACK
                                        s.Color = RED
                                        t.rightRotate(s)
                                        s = x.Parent.Right
                                }</span>
                                <span class="cov8" title="1">s.Color = x.Parent.Color //—Å–ª—É—á–∞–π 4
                                x.Parent.Color = BLACK
                                s.Right.Color = BLACK
                                t.leftRotate(x.Parent)
                                x = t.Root</span>
                        }
                } else<span class="cov8" title="1"> { //–∑–µ—Ä–∫–∞–ª—å–Ω–æ
                        s = x.Parent.Left
                        if s.Color == RED </span><span class="cov8" title="1">{
                                s.Color = BLACK
                                x.Parent.Color = RED
                                t.rightRotate(x.Parent)
                                s = x.Parent.Left
                        }</span>
                        <span class="cov8" title="1">if s.Right.Color == BLACK &amp;&amp; s.Left.Color == BLACK </span><span class="cov8" title="1">{
                                s.Color = RED
                                x = x.Parent
                        }</span> else<span class="cov8" title="1"> {
                                if s.Left.Color == BLACK </span><span class="cov8" title="1">{
                                        s.Right.Color = BLACK
                                        s.Color = RED
                                        t.leftRotate(s)
                                        s = x.Parent.Left
                                }</span>
                                <span class="cov8" title="1">s.Color = x.Parent.Color
                                x.Parent.Color = BLACK
                                s.Left.Color = BLACK
                                t.rightRotate(x.Parent)
                                x = t.Root</span>
                        }
                }
        }
        <span class="cov8" title="1">x.Color = BLACK</span> //x —Å—Ç–∞–ª —á–µ—Ä–Ω—ã–º
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫
func (t *RBTree) searchHelper(node *RBNode, key int) *RBNode <span class="cov8" title="1">{
        if node == t.TNULL || key == node.Key </span><span class="cov8" title="1">{
                return node //–Ω–∞—à–ª–∏ –∏–ª–∏ —Ç—É–ø–∏–∫
        }</span>
        <span class="cov8" title="1">if key &lt; node.Key </span><span class="cov8" title="1">{
                return t.searchHelper(node.Left, key) //–≤–ª–µ–≤–æ
        }</span>
        <span class="cov8" title="1">return t.searchHelper(node.Right, key)</span> //–≤–ø—Ä–∞–≤–æ
}

//–ü—É–±–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã

// Insert - –≤—Å—Ç–∞–≤–∫–∞ –∫–ª—é—á–∞
func (t *RBTree) Insert(key int) <span class="cov8" title="1">{
        node := &amp;RBNode{Key: key, Color: RED, Left: t.TNULL, Right: t.TNULL, Parent: nil} //–Ω–æ–≤—ã–π –∫—Ä–∞—Å–Ω—ã–π
        y := (*RBNode)(nil)
        x := t.Root

        for x != t.TNULL </span><span class="cov8" title="1">{ //—Å–ø—É—Å–∫ –≤–Ω–∏–∑
                y = x
                if node.Key &lt; x.Key </span><span class="cov8" title="1">{
                        x = x.Left
                }</span> else<span class="cov8" title="1"> {
                        x = x.Right
                }</span>
        }

        <span class="cov8" title="1">node.Parent = y //—Å—Ç–∞–≤–∏–º —Ä–æ–¥–∏—Ç–µ–ª—è
        if y == nil </span><span class="cov8" title="1">{
                t.Root = node //–∫–æ—Ä–µ–Ω—å
        }</span> else<span class="cov8" title="1"> if node.Key &lt; y.Key </span><span class="cov8" title="1">{
                y.Left = node //–ª–µ–≤—ã–π —Å—ã–Ω
        }</span> else<span class="cov8" title="1"> {
                y.Right = node //–ø—Ä–∞–≤—ã–π —Å—ã–Ω
        }</span>

        <span class="cov8" title="1">if node.Parent == nil </span><span class="cov8" title="1">{
                node.Color = BLACK //–∫–æ—Ä–µ–Ω—å —á–µ—Ä–Ω—ã–π
                return
        }</span>
        <span class="cov8" title="1">if node.Parent.Parent == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">t.insertFix(node)</span> //–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞
}

//—É–¥–∞–ª–µ–Ω–∏–µ –∫–ª—é—á–∞
func (t *RBTree) Delete(key int) <span class="cov8" title="1">{
        z := t.searchHelper(t.Root, key) //–∏—â–µ–º —É–∑–µ–ª
        if z == t.TNULL </span><span class="cov8" title="1">{
                fmt.Println("Key not found")
                return
        }</span>

        <span class="cov8" title="1">var x, y *RBNode
        y = z
        yOrigColor := y.Color

        if z.Left == t.TNULL </span><span class="cov8" title="1">{
                x = z.Right
                t.transplant(z, z.Right) //–∑–∞–º–µ–Ω–∞ –ø—Ä–∞–≤—ã–º
        }</span> else<span class="cov8" title="1"> if z.Right == t.TNULL </span><span class="cov8" title="1">{
                x = z.Left
                t.transplant(z, z.Left) //–∑–∞–º–µ–Ω–∞ –ª–µ–≤—ã–º
        }</span> else<span class="cov8" title="1"> {
                y = t.minimum(z.Right) //–∏—â–µ–º –ø—Ä–µ–µ–º–Ω–∏–∫–∞
                yOrigColor = y.Color
                x = y.Right
                if y.Parent == z </span><span class="cov8" title="1">{
                        x.Parent = y
                }</span> else<span class="cov8" title="1"> {
                        t.transplant(y, y.Right)
                        y.Right = z.Right
                        y.Right.Parent = y
                }</span>
                <span class="cov8" title="1">t.transplant(z, y)
                y.Left = z.Left
                y.Left.Parent = y
                y.Color = z.Color</span>
        }
        <span class="cov8" title="1">if yOrigColor == BLACK </span><span class="cov8" title="1">{
                t.deleteFix(x) //–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ –µ—Å–ª–∏ —É–¥–∞–ª–∏–ª–∏ —á–µ—Ä–Ω—ã–π
        }</span>
}

// Search - –ø–æ–∏—Å–∫ –∫–ª—é—á–∞
func (t *RBTree) Search(k int) bool <span class="cov8" title="1">{
        return t.searchHelper(t.Root, k) != t.TNULL
}</span>

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è –ø–µ—á–∞—Ç—å
func (t *RBTree) printHelper(root *RBNode, indent string, last bool) <span class="cov8" title="1">{
        if root != t.TNULL </span><span class="cov8" title="1">{
                fmt.Print(indent)
                if last </span><span class="cov8" title="1">{
                        fmt.Print("R----") //–ø—Ä–∞–≤—ã–π
                        indent += "   "
                }</span> else<span class="cov8" title="1"> {
                        fmt.Print("L----") //–ª–µ–≤—ã–π
                        indent += "|  "
                }</span>
                <span class="cov8" title="1">color := "BLK"
                if root.Color == RED </span><span class="cov8" title="1">{
                        color = "RED"
                }</span>
                <span class="cov8" title="1">fmt.Printf("%d(%s)\n", root.Key, color)
                t.printHelper(root.Left, indent, false) //—Ä–µ–∫ –ª–µ–≤–æ
                t.printHelper(root.Right, indent, true)</span> //—Ä–µ–∫ –ø—Ä–∞–≤–æ
        }
}

// Print - –∫—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥ –¥–µ—Ä–µ–≤–∞
func (t *RBTree) Print() <span class="cov8" title="1">{
        if t.Root == t.TNULL </span><span class="cov0" title="0">{
                fmt.Println("Tree is empty")
        }</span> else<span class="cov8" title="1"> {
                t.printHelper(t.Root, "", true)
        }</span>
}

//–°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è

// Save - —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ JSON
func (t *RBTree) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename) //—Ñ–∞–π–ª
        if err != nil </span><span class="cov0" title="0">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()
        return json.NewEncoder(file).Encode(t)</span> //–ø–∏—à–µ–º
}

// Load - –∑–∞–≥—Ä—É–∑–∫–∞ –∏–∑ JSON
func (t *RBTree) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename) //–æ—Ç–∫—Ä—ã–≤–∞–µ–º
        if err != nil </span><span class="cov8" title="1">{ return err }</span>
        <span class="cov8" title="1">defer file.Close()

        // –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∂–∞–µ–º "—Å—ã—Ä—É—é" —Å—Ç—Ä—É–∫—Ç—É—Ä—É
        if err := json.NewDecoder(file).Decode(t); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
//–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ JSON –ø–æ–ª–µ Parent –ø–æ—Ç–µ—Ä—è–Ω–æ (–º—ã –µ–≥–æ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–ª–∏, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Ü–∏–∫–ª–æ–≤),–∏ TNULL –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.
        <span class="cov8" title="1">t.TNULL = &amp;RBNode{Color: BLACK}//–ù–æ–≤—ã–π TNULL
        t.fixParentsAndTNULL(t.Root)//–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —á–∏–Ω–∏–º
        return nil</span>
}

//–≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–≤—è–∑–∏ Parent –∏ –∑–∞–º–µ–Ω—è–µ—Ç nil –Ω–∞ TNULL
func (t *RBTree) fixParentsAndTNULL(node *RBNode) <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return
        }</span>
        // –ï—Å–ª–∏ —É–∑–µ–ª –±—ã–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω –∫–∞–∫ –ª–∏—Å—Ç (nil –≤ json), –¥–µ–ª–∞–µ–º –µ–≥–æ TNULL
        <span class="cov8" title="1">if node.Left == nil </span><span class="cov8" title="1">{
                node.Left = t.TNULL
        }</span> else<span class="cov8" title="1"> {
                node.Left.Parent = node
                t.fixParentsAndTNULL(node.Left)
        }</span>

        <span class="cov8" title="1">if node.Right == nil </span><span class="cov8" title="1">{
                node.Right = t.TNULL
        }</span> else<span class="cov8" title="1"> {
                node.Right.Parent = node
                t.fixParentsAndTNULL(node.Right)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
